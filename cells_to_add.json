{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "---\n",
                "## Part 4: Static Visualization / 정적 시각화 (2D/3D Model Analysis)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# =============================================================================\n",
                "# 4.1 2D Smile Curves (Slices) / 2D 스마일 커브 (단면 분석)\n",
                "# =============================================================================\n",
                "def plot_2d_smile_comparison(market_strikes, market_imvol, market_T, model_prices_dict, S0, r, target_T_idx=0):\n",
                "    unique_T = np.unique(market_T)\n",
                "    if target_T_idx >= len(unique_T):\n",
                "        target_T_idx = 0\n",
                "    \n",
                "    target_T = unique_T[target_T_idx]\n",
                "    mask = market_T == target_T\n",
                "    \n",
                "    strikes = market_strikes[mask]\n",
                "    market_iv_slice = market_imvol[mask]\n",
                "    \n",
                "    fig = go.Figure()\n",
                "    \n",
                "    # Market Data\n",
                "    fig.add_trace(go.Scatter(x=strikes, y=market_iv_slice, mode='markers', name='Market', marker=dict(size=10, color='black', symbol='x')))\n",
                "    \n",
                "    # Models\n",
                "    colors = ['blue', 'green', 'red', 'orange', 'purple', 'cyan', 'magenta', 'lime', 'brown', 'teal']\n",
                "    for i, (model_name, prices) in enumerate(model_prices_dict.items()):\n",
                "        model_prices_slice = prices[mask]\n",
                "        # Calculate Implied Vol for Model Prices\n",
                "        model_iv = []\n",
                "        for p, k in zip(model_prices_slice, strikes):\n",
                "             iv = implied_volatility(p, S0, k, target_T, r)\n",
                "             model_iv.append(iv)\n",
                "        \n",
                "        fig.add_trace(go.Scatter(x=strikes, y=model_iv, mode='lines', name=model_name, line=dict(color=colors[i % len(colors)], width=2)))\n",
                "\n",
                "    fig.update_layout(\n",
                "        title=f'Volatility Smile Comparison (T={target_T:.3f})',\n",
                "        xaxis_title='Strike Price',\n",
                "        yaxis_title='Implied Volatility',\n",
                "        template='plotly_white',\n",
                "        width=900, height=600\n",
                "    )\n",
                "    fig.show()\n",
                "\n",
                "# Plot for the first and last maturity\n",
                "plot_2d_smile_comparison(market_strikes, market_iv, market_T, model_prices_dict, S0, r, target_T_idx=0)\n",
                "plot_2d_smile_comparison(market_strikes, market_iv, market_T, model_prices_dict, S0, r, target_T_idx=-1)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# =============================================================================\n",
                "# 4.2 3D Implied Volatility Surface / 3D 내재변동성 표면\n",
                "# =============================================================================\n",
                "# Grid for Surface\n",
                "grid_K, grid_T = np.meshgrid(\n",
                "    np.linspace(market_strikes.min(), market_strikes.max(), 30),\n",
                "    np.linspace(market_T.min(), market_T.max(), 30)\n",
                ")\n",
                "\n",
                "# Interpolate Market IV\n",
                "grid_IV = griddata((market_strikes, market_T), market_iv, (grid_K, grid_T), method='cubic')\n",
                "\n",
                "fig = go.Figure(data=[go.Surface(x=grid_K, y=grid_T, z=grid_IV, colorscale='Viridis', opacity=0.8, name='Market Surface')])\n",
                "\n",
                "# Add Scatter Points\n",
                "fig.add_trace(go.Scatter3d(\n",
                "    x=market_strikes, y=market_T, z=market_iv,\n",
                "    mode='markers', marker=dict(size=3, color='red'), name='Market Data'\n",
                "))\n",
                "\n",
                "fig.update_layout(\n",
                "    title='Market Implied Volatility Surface',\n",
                "    scene=dict(xaxis_title='Strike', yaxis_title='Time to Maturity', zaxis_title='Implied Volatility'),\n",
                "    width=900, height=700,\n",
                "    template='plotly_dark' # Dark mode for better 3D visibility\n",
                ")\n",
                "fig.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "---\n",
                "## Part 5: 4D Spacetime Visualization / 4D 시공간 시각화\n",
                "\n",
                "Quantum Path Integral vs Neural SDE: Path Distribution Analysis.\n",
                "양자 경로 적분과 뉴럴 SDE의 \"경로 분포\"를 시각적으로 비교합니다."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# =============================================================================\n",
                "# 5.1 Generate Paths for Visualization / 시각화를 위한 경로 생성\n",
                "# =============================================================================\n",
                "viz_paths = 100  # Number of paths to visualize (keep it small for rendering)\n",
                "viz_T = 1.0      # Visualization horizon\n",
                "\n",
                "# 1. Quantum (Heston-based) Paths\n",
                "sim_quantum = MarketSimulator(mu=r, kappa=2.0, theta=0.04, xi=0.3, rho=-0.7, device=device)\n",
                "S_quant, v_quant = sim_quantum.simulate(S0, 0.04, viz_T, dt, viz_paths, 'heston')\n",
                "S_quant = S_quant.cpu().numpy()\n",
                "\n",
                "# 2. Neural SDE Paths\n",
                "neural_sde.drift_net.eval()\n",
                "neural_sde.diff_net.eval()\n",
                "with torch.no_grad():\n",
                "    S_neural, _ = neural_sde.simulate(S0, viz_T, dt, viz_paths)\n",
                "    S_neural = S_neural.cpu().numpy()\n",
                "\n",
                "time_steps = np.linspace(0, viz_T, S_quant.shape[1])\n",
                "print(\"Paths generated for visualization.\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# =============================================================================\n",
                "# 5.2 4D Path Visualizer / 4D 경로 시각화기\n",
                "# =============================================================================\n",
                "def plot_spacetime_paths(S_paths, title, color_theme='Blues'):\n",
                "    fig = go.Figure()\n",
                "    \n",
                "    # Plot individual paths\n",
                "    for i in range(min(50, S_paths.shape[0])): # Limit to 50 paths\n",
                "        fig.add_trace(go.Scatter3d(\n",
                "            x=time_steps, \n",
                "            y=np.full_like(time_steps, i), # Path Index on Y-axis\n",
                "            z=S_paths[i, :],\n",
                "            mode='lines',\n",
                "            line=dict(width=2, color=S_paths[i, :], colorscale=color_theme),\n",
                "            name=f'Path {i}'\n",
                "        ))\n",
                "\n",
                "    fig.update_layout(\n",
                "        title=title,\n",
                "        scene=dict(\n",
                "            xaxis_title='Time (t)',\n",
                "            yaxis_title='Path Index (Microstate)',\n",
                "            zaxis_title='Price (S_t)'\n",
                "        ),\n",
                "        width=900, height=700,\n",
                "        template='plotly_dark',\n",
                "        showlegend=False\n",
                "    )\n",
                "    fig.show()\n",
                "\n",
                "print(\"Visualizing Quantum Path Integral Microstates...\")\n",
                "plot_spacetime_paths(S_quant, \"Quantum Path Integral: Feynman Paths\", 'Viridis')\n",
                "\n",
                "print(\"Visualizing Neural SDE Microstates...\")\n",
                "plot_spacetime_paths(S_neural, \"Neural SDE: Learned Stochastic Paths\", 'Plasma')"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "---\n",
                "## Conclusion / 결론\n",
                "\n",
                "**1. Performance (RMSE):** XGBoost showed the best fit, highlighting ML's interpolation power.\n",
                "**2. Physics (Consistency):** Heston/Quantum models provided robust, explainable outcomes.\n",
                "**3. Innovation (Neural SDE):** Successfully demonstrated a hybrid Neural-SDE approach creating realistic paths from scratch.\n",
                "\n",
                "This concludes the Grand Model Comparison."
            ]
        }
    ]
}
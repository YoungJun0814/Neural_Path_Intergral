{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### ğŸ› ï¸ Part 4.0: Generate Missing Model Prices / ëˆ„ë½ëœ ëª¨ë¸ ê°€ê²© ë°ì´í„° ìƒì„±\n",
                "\n",
                "SDE ëª¨ë¸(Heston, Merton ë“±)ê³¼ Neural SDEì˜ ì˜ˆì¸¡ ê°€ê²©ì´ `model_prices_dict`ì— ì €ì¥ë˜ì§€ ì•Šì•„ ê·¸ë˜í”„ì— ë‚˜íƒ€ë‚˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. \n",
                "ì €ì¥ëœ ìµœì  íŒŒë¼ë¯¸í„°(`calibration_results`)ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ê²©ì„ ë‹¤ì‹œ ê³„ì‚°í•˜ê³  ê·¸ë˜í”„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.\n",
                "\n",
                "Missing model prices (Heston, Merton, etc.) are regenerated here using the calibrated parameters."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# =============================================================================\n",
                "# 4.0 Restore Missing Model Data / ëˆ„ë½ëœ ë°ì´í„° ë³µêµ¬\n",
                "# =============================================================================\n",
                "print(\"Restoring missing model data for visualization...\")\n",
                "\n",
                "# 1. Restore SDE Models (Heston, Merton, Bates, SVJJ)\n",
                "for model_name in ['Heston', 'Merton', 'Bates', 'SVJJ']:\n",
                "    if model_name in calibration_results:\n",
                "        params = calibration_results[model_name]['params']\n",
                "        \n",
                "        # Parameter Unpacking (Same as calibration logic)\n",
                "        params_dict = {'mu': r}\n",
                "        if model_name == 'Heston':\n",
                "            kappa, theta, xi, rho = params\n",
                "            params_dict.update({'kappa': kappa, 'theta': theta, 'xi': xi, 'rho': rho, 'jump_lambda': 0})\n",
                "            val_type = 'heston'\n",
                "        elif model_name == 'Merton':\n",
                "            sigma, jump_lambda, jump_mean, jump_std = params\n",
                "            params_dict.update({'kappa': 10.0, 'theta': sigma**2, 'xi': 0.001, 'rho': 0.0, \n",
                "                              'jump_lambda': jump_lambda, 'jump_mean': jump_mean, 'jump_std': jump_std})\n",
                "            val_type = 'bates'\n",
                "        elif model_name == 'Bates':\n",
                "            kappa, theta, xi, rho, jump_lambda, jump_mean, jump_std = params\n",
                "            params_dict.update({'kappa': kappa, 'theta': theta, 'xi': xi, 'rho': rho, \n",
                "                              'jump_lambda': jump_lambda, 'jump_mean': jump_mean, 'jump_std': jump_std})\n",
                "            val_type = 'bates'\n",
                "        elif model_name == 'SVJJ':\n",
                "            kappa, theta, xi, rho, jump_lambda, jump_mean, jump_std, vol_jump_mean = params\n",
                "            params_dict.update({'kappa': kappa, 'theta': theta, 'xi': xi, 'rho': rho, \n",
                "                              'jump_lambda': jump_lambda, 'jump_mean': jump_mean, 'jump_std': jump_std, 'vol_jump_mean': vol_jump_mean})\n",
                "            val_type = 'svjj'\n",
                "            \n",
                "        # Simulation & Pricing\n",
                "        model_prices = []\n",
                "        for T_val in np.unique(market_T):\n",
                "             mask = market_T == T_val\n",
                "             strikes_T = market_strikes[mask]\n",
                "             S_paths, _ = simulator.simulate(S0=S0, v0=params_dict.get('theta', 0.04), T=T_val, dt=dt, \n",
                "                                           num_paths=N_paths, model_type=val_type, override_params=params_dict)\n",
                "             S_final = S_paths[:, -1]\n",
                "             S_corr = S_final * (S0 / torch.mean(S_final))\n",
                "             \n",
                "             # Pay off\n",
                "             strikes_gpu = torch.tensor(strikes_T, device=device).float()\n",
                "             payoffs = torch.maximum(S_corr.unsqueeze(1) - strikes_gpu, torch.tensor(0.0, device=device))\n",
                "             prices = (torch.mean(payoffs, dim=0) * np.exp(-r * T_val)).cpu().numpy()\n",
                "             model_prices.extend(prices)\n",
                "        \n",
                "        model_prices_dict[model_name] = np.array(model_prices)\n",
                "        print(f\"âœ… {model_name} prices restored.\")\n",
                "\n",
                "# 2. Restore rBergomi\n",
                "if 'rBergomi' in calibration_results:\n",
                "    params = calibration_results['rBergomi']['params']\n",
                "    H, eta, xi, rho = params\n",
                "    rb_sim = RBergomiSimulator(H=H, eta=eta, xi=xi, rho=rho, device=device)\n",
                "    \n",
                "    model_prices = []\n",
                "    for T_val in np.unique(market_T):\n",
                "         mask = market_T == T_val\n",
                "         S_paths, _ = rb_sim.simulate(S0=S0, T=T_val, dt=dt, num_paths=N_paths, mu=r)\n",
                "         S_final = S_paths[:, -1]\n",
                "         S_corr = S_final * (S0 / torch.mean(S_final))\n",
                "         \n",
                "         strikes_T = market_strikes[mask]\n",
                "         strikes_gpu = torch.tensor(strikes_T, device=device).float()\n",
                "         payoffs = torch.maximum(S_corr.unsqueeze(1) - strikes_gpu, torch.tensor(0.0, device=device))\n",
                "         prices = (torch.mean(payoffs, dim=0) * np.exp(-r * T_val)).cpu().numpy()\n",
                "         model_prices.extend(prices)\n",
                "    \n",
                "    model_prices_dict['rBergomi'] = np.array(model_prices)\n",
                "    print(f\"âœ… rBergomi prices restored.\")\n",
                "\n",
                "# 3. Restore Neural SDE\n",
                "neural_sde.drift_net.eval()\n",
                "neural_sde.diff_net.eval()\n",
                "all_model_prices = []\n",
                "with torch.no_grad():\n",
                "    for T_val in np.unique(market_T):\n",
                "        mask = market_T == T_val\n",
                "        # Use dynamic dt from fix\n",
                "        sim_dt = min(0.01, T_val / 3.0)\n",
                "        S_paths, _ = neural_sde.simulate(S0, T_val, sim_dt, N_paths)\n",
                "        S_final = S_paths[:, -1]\n",
                "        S_corr = S_final * (S0 / torch.mean(S_final))\n",
                "        strikes_gpu = torch.tensor(market_strikes[mask], device=device).float()\n",
                "        payoffs = torch.maximum(S_corr.unsqueeze(1) - strikes_gpu, torch.tensor(0.0, device=device))\n",
                "        model_prices = (torch.mean(payoffs, dim=0) * np.exp(-r * T_val)).cpu().numpy()\n",
                "        all_model_prices.extend(model_prices)\n",
                "\n",
                "model_prices_dict['Neural SDE'] = np.array(all_model_prices)\n",
                "print(f\"âœ… Neural SDE prices restored.\")\n",
                "\n",
                "print(f\"\\nAll models in model_prices_dict: {list(model_prices_dict.keys())}\")"
            ]
        }
    ]
}